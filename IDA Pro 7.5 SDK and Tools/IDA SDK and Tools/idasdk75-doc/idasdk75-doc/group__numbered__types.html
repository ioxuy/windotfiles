<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: Numbered types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Numbered types</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions to work with numbered (ordinal) types. </p>
<p>Numbered types may be named or anonymous. They are referenced by their ordinal number. Access to them is faster because there is no need to resolve their names. Also, they can stay anonymous and be aliased. They can be used only in the local type library created by IDA (in idati). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab1fb33088b41c01ab02e1d7739ae3d67"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gab1fb33088b41c01ab02e1d7739ae3d67">enable_numbered_types</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, bool enable)</td></tr>
<tr class="memdesc:gab1fb33088b41c01ab02e1d7739ae3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the use of numbered types in til.  <a href="#gab1fb33088b41c01ab02e1d7739ae3d67">More...</a><br /></td></tr>
<tr class="separator:gab1fb33088b41c01ab02e1d7739ae3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d006198b689ee58c8832489cb87ea70"><td class="memItemLeft" align="right" valign="top"><a id="ga3d006198b689ee58c8832489cb87ea70"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga3d006198b689ee58c8832489cb87ea70">get_numbered_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **type=NULL, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fields=NULL, const char **cmt=NULL, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fieldcmts=NULL, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=NULL)</td></tr>
<tr class="memdesc:ga3d006198b689ee58c8832489cb87ea70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a type by its ordinal number. <br /></td></tr>
<tr class="separator:ga3d006198b689ee58c8832489cb87ea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7a68bdec901b7fbf1c0bf324ddf126"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga1f7a68bdec901b7fbf1c0bf324ddf126">alloc_type_ordinals</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, int qty)</td></tr>
<tr class="memdesc:ga1f7a68bdec901b7fbf1c0bf324ddf126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a range of ordinal numbers for new types.  <a href="#ga1f7a68bdec901b7fbf1c0bf324ddf126">More...</a><br /></td></tr>
<tr class="separator:ga1f7a68bdec901b7fbf1c0bf324ddf126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e79e63d11375aa35947c987ee15931"><td class="memItemLeft" align="right" valign="top"><a id="ga42e79e63d11375aa35947c987ee15931"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga42e79e63d11375aa35947c987ee15931">alloc_type_ordinal</a> (<a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:ga42e79e63d11375aa35947c987ee15931"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__numbered__types.html#ga1f7a68bdec901b7fbf1c0bf324ddf126">alloc_type_ordinals</a>(ti, 1) <br /></td></tr>
<tr class="separator:ga42e79e63d11375aa35947c987ee15931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac850f1c54d5b4c607d64ddf76691814f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gac850f1c54d5b4c607d64ddf76691814f">get_ordinal_qty</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:gac850f1c54d5b4c607d64ddf76691814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of allocated ordinals.  <a href="#gac850f1c54d5b4c607d64ddf76691814f">More...</a><br /></td></tr>
<tr class="separator:gac850f1c54d5b4c607d64ddf76691814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2052794beeb4a5968dcf0b12a525801"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="group__named__types.html#ga4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gaf2052794beeb4a5968dcf0b12a525801">set_numbered_type</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, int ntf_flags, const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fields=NULL, const char *cmt=NULL, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fldcmts=NULL, const <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=NULL)</td></tr>
<tr class="memdesc:gaf2052794beeb4a5968dcf0b12a525801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a type in the til.  <a href="#gaf2052794beeb4a5968dcf0b12a525801">More...</a><br /></td></tr>
<tr class="separator:gaf2052794beeb4a5968dcf0b12a525801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63cf655e113e97c7d0abc8d42e7e98f4"><td class="memItemLeft" align="right" valign="top"><a id="ga63cf655e113e97c7d0abc8d42e7e98f4"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga63cf655e113e97c7d0abc8d42e7e98f4">del_numbered_type</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:ga63cf655e113e97c7d0abc8d42e7e98f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a numbered type. <br /></td></tr>
<tr class="separator:ga63cf655e113e97c7d0abc8d42e7e98f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa083016ad05fe5db5b57b25a98cf9d7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gaaa083016ad05fe5db5b57b25a98cf9d7">set_type_alias</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> src_ordinal, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> dst_ordinal)</td></tr>
<tr class="memdesc:gaaa083016ad05fe5db5b57b25a98cf9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type alias.  <a href="#gaaa083016ad05fe5db5b57b25a98cf9d7">More...</a><br /></td></tr>
<tr class="separator:gaaa083016ad05fe5db5b57b25a98cf9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3df2e4834eeaf173579f92c5feb3b88"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gaa3df2e4834eeaf173579f92c5feb3b88">get_alias_target</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:gaa3df2e4834eeaf173579f92c5feb3b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the final alias destination.  <a href="#gaa3df2e4834eeaf173579f92c5feb3b88">More...</a><br /></td></tr>
<tr class="separator:gaa3df2e4834eeaf173579f92c5feb3b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5f88db314fdff319b9d79ead7c3865"><td class="memItemLeft" align="right" valign="top"><a id="ga5a5f88db314fdff319b9d79ead7c3865"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga5a5f88db314fdff319b9d79ead7c3865">get_type_ordinal</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *name)</td></tr>
<tr class="memdesc:ga5a5f88db314fdff319b9d79ead7c3865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type ordinal by its name. <br /></td></tr>
<tr class="separator:ga5a5f88db314fdff319b9d79ead7c3865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbaa89dd65a0edd6a3a5c0528347f585"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gabbaa89dd65a0edd6a3a5c0528347f585">get_numbered_type_name</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:gabbaa89dd65a0edd6a3a5c0528347f585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type name (if exists) by its ordinal.  <a href="#gabbaa89dd65a0edd6a3a5c0528347f585">More...</a><br /></td></tr>
<tr class="separator:gabbaa89dd65a0edd6a3a5c0528347f585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ed1d69ef90da349923a780f84f851a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gab5ed1d69ef90da349923a780f84f851a">create_numbered_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ord)</td></tr>
<tr class="memdesc:gab5ed1d69ef90da349923a780f84f851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create anonymous name for numbered type.  <a href="#gab5ed1d69ef90da349923a780f84f851a">More...</a><br /></td></tr>
<tr class="separator:gab5ed1d69ef90da349923a780f84f851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84bd5e43c505cc3103cad24ce05d6d1d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga84bd5e43c505cc3103cad24ce05d6d1d">is_ordinal_name</a> (const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *ord=NULL)</td></tr>
<tr class="memdesc:ga84bd5e43c505cc3103cad24ce05d6d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the name is an ordinal name.  <a href="#ga84bd5e43c505cc3103cad24ce05d6d1d">More...</a><br /></td></tr>
<tr class="separator:ga84bd5e43c505cc3103cad24ce05d6d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c7701a03bd988d81f5ed27d2f5bb39"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gaf4c7701a03bd988d81f5ed27d2f5bb39">get_ordinal_from_idb_type</a> (const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="memdesc:gaf4c7701a03bd988d81f5ed27d2f5bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ordinal number of an idb type (struct/enum).  <a href="#gaf4c7701a03bd988d81f5ed27d2f5bb39">More...</a><br /></td></tr>
<tr class="separator:gaf4c7701a03bd988d81f5ed27d2f5bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3437c158380092035b7cae165d7512fd"><td class="memItemLeft" align="right" valign="top"><a id="ga3437c158380092035b7cae165d7512fd"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga3437c158380092035b7cae165d7512fd">is_autosync</a> (const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="memdesc:ga3437c158380092035b7cae165d7512fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the specified idb type automatically synchronized? <br /></td></tr>
<tr class="separator:ga3437c158380092035b7cae165d7512fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a920a13cb45e4731cd68b7d2556588"><td class="memItemLeft" align="right" valign="top"><a id="ga55a920a13cb45e4731cd68b7d2556588"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga55a920a13cb45e4731cd68b7d2556588">is_autosync</a> (const char *name, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif)</td></tr>
<tr class="memdesc:ga55a920a13cb45e4731cd68b7d2556588"><td class="mdescLeft">&#160;</td><td class="mdescRight">copydoc <a class="el" href="group__numbered__types.html#ga3437c158380092035b7cae165d7512fd" title="Is the specified idb type automatically synchronized?">is_autosync(const char*, const type_t *)</a> <br /></td></tr>
<tr class="separator:ga55a920a13cb45e4731cd68b7d2556588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600c885cb0b722c6f392bf83f467442a"><td class="memItemLeft" align="right" valign="top"><a id="ga600c885cb0b722c6f392bf83f467442a"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga600c885cb0b722c6f392bf83f467442a">build_anon_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fields)</td></tr>
<tr class="memdesc:ga600c885cb0b722c6f392bf83f467442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a name like $hex_numbers based on the field types and names. <br /></td></tr>
<tr class="separator:ga600c885cb0b722c6f392bf83f467442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8130d2b60d3ea3abd2cf53afafe6ba"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#ga8a8130d2b60d3ea3abd2cf53afafe6ba">compact_numbered_types</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> min_ord=0, <a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *p_ordmap=NULL, int flags=0)</td></tr>
<tr class="memdesc:ga8a8130d2b60d3ea3abd2cf53afafe6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact numbered types to get rid of empty slots.  <a href="#ga8a8130d2b60d3ea3abd2cf53afafe6ba">More...</a><br /></td></tr>
<tr class="separator:ga8a8130d2b60d3ea3abd2cf53afafe6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad447f7a11c27974f14c5b6d303ed4213"><td class="memItemLeft" align="right" valign="top"><a id="gad447f7a11c27974f14c5b6d303ed4213"></a>
const <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numbered__types.html#gad447f7a11c27974f14c5b6d303ed4213">BADORD</a> = <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>(-1)</td></tr>
<tr class="memdesc:gad447f7a11c27974f14c5b6d303ed4213"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid type ordinal <br /></td></tr>
<tr class="separator:gad447f7a11c27974f14c5b6d303ed4213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab1fb33088b41c01ab02e1d7739ae3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fb33088b41c01ab02e1d7739ae3d67">&#9670;&nbsp;</a></span>enable_numbered_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export enable_numbered_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the use of numbered types in til. </p>
<p>Currently it is impossible to disable numbered types once they are enabled </p>

</div>
</div>
<a id="ga1f7a68bdec901b7fbf1c0bf324ddf126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7a68bdec901b7fbf1c0bf324ddf126">&#9670;&nbsp;</a></span>alloc_type_ordinals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export alloc_type_ordinals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a range of ordinal numbers for new types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library </td></tr>
    <tr><td class="paramname">qty</td><td>number of ordinals to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first ordinal. 0 means failure. </dd></dl>

</div>
</div>
<a id="gac850f1c54d5b4c607d64ddf76691814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac850f1c54d5b4c607d64ddf76691814f">&#9670;&nbsp;</a></span>get_ordinal_qty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_ordinal_qty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of allocated ordinals. </p>
<dl class="section return"><dt>Returns</dt><dd>uint32(-1) if failed </dd></dl>

</div>
</div>
<a id="gaf2052794beeb4a5968dcf0b12a525801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2052794beeb4a5968dcf0b12a525801">&#9670;&nbsp;</a></span>set_numbered_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="group__named__types.html#ga4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a> ida_export set_numbered_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *&#160;</td>
          <td class="paramname"><em>fields</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *&#160;</td>
          <td class="paramname"><em>fldcmts</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *&#160;</td>
          <td class="paramname"><em>sclass</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a type in the til. </p>
<p>'name' may be NULL for anonymous types. The specified ordinal must be free (no other type is using it). For ntf_flags, only <a class="el" href="group___n_t_f__.html#ga99d425180386ad9f256f191e88ff1ffe" title="replace original type (for set_named_type)">NTF_REPLACE</a> is consulted. </p>

</div>
</div>
<a id="gaaa083016ad05fe5db5b57b25a98cf9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa083016ad05fe5db5b57b25a98cf9d7">&#9670;&nbsp;</a></span>set_type_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_type_alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>src_ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>dst_ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a type alias. </p>
<p>Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all reference to srctype by dsttype. </p>

</div>
</div>
<a id="gaa3df2e4834eeaf173579f92c5feb3b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3df2e4834eeaf173579f92c5feb3b88">&#9670;&nbsp;</a></span>get_alias_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_alias_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the final alias destination. </p>
<p>If the ordinal has not been aliased, return the specified ordinal itself If failed, returns 0. </p>

</div>
</div>
<a id="gabbaa89dd65a0edd6a3a5c0528347f585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbaa89dd65a0edd6a3a5c0528347f585">&#9670;&nbsp;</a></span>get_numbered_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char* ida_export get_numbered_type_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type name (if exists) by its ordinal. </p>
<p>If the type is anonymous, returns "". If failed, returns NULL </p>

</div>
</div>
<a id="gab5ed1d69ef90da349923a780f84f851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ed1d69ef90da349923a780f84f851a">&#9670;&nbsp;</a></span>create_numbered_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export create_numbered_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>ord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create anonymous name for numbered type. </p>
<p>This name can be used to reference a numbered type by its ordinal Ordinal names have the following format: '#' + set_de(ord) Returns: -1 if error, otherwise the name length </p>

</div>
</div>
<a id="ga84bd5e43c505cc3103cad24ce05d6d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84bd5e43c505cc3103cad24ce05d6d1d">&#9670;&nbsp;</a></span>is_ordinal_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_ordinal_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *&#160;</td>
          <td class="paramname"><em>ord</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the name is an ordinal name. </p>
<p>Ordinal names have the following format: '#' + set_de(ord) </p>

</div>
</div>
<a id="gaf4c7701a03bd988d81f5ed27d2f5bb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4c7701a03bd988d81f5ed27d2f5bb39">&#9670;&nbsp;</a></span>get_ordinal_from_idb_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_ordinal_from_idb_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ordinal number of an idb type (struct/enum). </p>
<p>The 'type' parameter is used only to determine the kind of the type (struct or enum) Use this function to find out the correspondence between idb types and til types </p>

</div>
</div>
<a id="ga8a8130d2b60d3ea3abd2cf53afafe6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8130d2b60d3ea3abd2cf53afafe6ba">&#9670;&nbsp;</a></span>compact_numbered_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export compact_numbered_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>min_ord</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *&#160;</td>
          <td class="paramname"><em>p_ordmap</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compact numbered types to get rid of empty slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library to compact </td></tr>
    <tr><td class="paramname">min_ord</td><td>minimal ordinal number to start to compact. lower ordinals are not modified </td></tr>
    <tr><td class="paramname">p_ordmap</td><td>the resulting mapping (for example, the new ordinal of min_ord will be in ordmap[0]) </td></tr>
    <tr><td class="paramname">flags</td><td>reserved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of freed type slots </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
