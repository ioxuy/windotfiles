<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: Segment manipulation functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Segment manipulation functions<div class="ingroups"><a class="el" href="group__seg.html">Segments</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Add/Delete/Modify segments. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___a_d_d_s_e_g__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_d_s_e_g__.html">Add segment flags</a></td></tr>
<tr class="memdesc:group___a_d_d_s_e_g__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed as 'flags' parameter to <a class="el" href="group__seg__man.html#gaa38d0afa3faaa85ce63da0a69882bc60" title="Add a new segment.">add_segm_ex()</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_e_g_m_o_d__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a></td></tr>
<tr class="memdesc:group___s_e_g_m_o_d__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by functions in <a class="el" href="group__seg__man.html">Segment manipulation functions</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___m_s_f__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_f__.html">Move segment flags</a></td></tr>
<tr class="memdesc:group___m_s_f__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed as 'flags' parameter to <a class="el" href="group__seg__man.html#gab3c11fbdf0ac345cb618b8b0ad3ef04c" title="Move a segment to a new address.">move_segm()</a> and <a class="el" href="group__seg__man.html#gaa5f20d1b84b6cbccb5a4b173f26e3599" title="Rebase the whole program by &#39;delta&#39; bytes.">rebase_program()</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___m_o_v_e___s_e_g_m__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_v_e___s_e_g_m__.html">Move segment result codes</a></td></tr>
<tr class="memdesc:group___m_o_v_e___s_e_g_m__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values for <a class="el" href="group__seg__man.html#gab3c11fbdf0ac345cb618b8b0ad3ef04c" title="Move a segment to a new address.">move_segm()</a> add <a class="el" href="group__seg__man.html#gaa5f20d1b84b6cbccb5a4b173f26e3599" title="Rebase the whole program by &#39;delta&#39; bytes.">rebase_program()</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s_s__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_s__.html">Change segment status result codes</a></td></tr>
<tr class="memdesc:group___c_s_s__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values for <a class="el" href="group__seg__man.html#ga4ad15e77b3eb0f53f1b5083aa0c3a70b" title="Convert a debugger segment to a regular segment and vice versa.">change_segment_status()</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa38d0afa3faaa85ce63da0a69882bc60"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gaa38d0afa3faaa85ce63da0a69882bc60">add_segm_ex</a> (<a class="el" href="classsegment__t.html">segment_t</a> *NONNULL s, const char *name, const char *sclass, int flags)</td></tr>
<tr class="memdesc:gaa38d0afa3faaa85ce63da0a69882bc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new segment.  <a href="#gaa38d0afa3faaa85ce63da0a69882bc60">More...</a><br /></td></tr>
<tr class="separator:gaa38d0afa3faaa85ce63da0a69882bc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f6ee9677c2605aeac9541e38e54025"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga59f6ee9677c2605aeac9541e38e54025">add_segm</a> (ea_t para, ea_t start, ea_t end, const char *name, const char *sclass, int flags=0)</td></tr>
<tr class="memdesc:ga59f6ee9677c2605aeac9541e38e54025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new segment, second form.  <a href="#ga59f6ee9677c2605aeac9541e38e54025">More...</a><br /></td></tr>
<tr class="separator:ga59f6ee9677c2605aeac9541e38e54025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabebbd185abaf370753d5ea59d32d9985"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gabebbd185abaf370753d5ea59d32d9985">del_segm</a> (ea_t ea, int flags)</td></tr>
<tr class="memdesc:gabebbd185abaf370753d5ea59d32d9985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a segment.  <a href="#gabebbd185abaf370753d5ea59d32d9985">More...</a><br /></td></tr>
<tr class="separator:gabebbd185abaf370753d5ea59d32d9985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e848ee2505a32634309a914195fe141"><td class="memItemLeft" align="right" valign="top"><a id="ga9e848ee2505a32634309a914195fe141"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga9e848ee2505a32634309a914195fe141">get_segm_qty</a> (void)</td></tr>
<tr class="memdesc:ga9e848ee2505a32634309a914195fe141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of segments. <br /></td></tr>
<tr class="separator:ga9e848ee2505a32634309a914195fe141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe3790d2192e868f169f36b97b9afb38"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gafe3790d2192e868f169f36b97b9afb38">getseg</a> (ea_t ea)</td></tr>
<tr class="memdesc:gafe3790d2192e868f169f36b97b9afb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by linear address.  <a href="#gafe3790d2192e868f169f36b97b9afb38">More...</a><br /></td></tr>
<tr class="separator:gafe3790d2192e868f169f36b97b9afb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga981ad2476fa596106a40f407583413cb"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga981ad2476fa596106a40f407583413cb">getnseg</a> (int n)</td></tr>
<tr class="memdesc:ga981ad2476fa596106a40f407583413cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by its number.  <a href="#ga981ad2476fa596106a40f407583413cb">More...</a><br /></td></tr>
<tr class="separator:ga981ad2476fa596106a40f407583413cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73fd60fa5ec55b12441ecbf3224f742"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gab73fd60fa5ec55b12441ecbf3224f742">get_segm_num</a> (ea_t ea)</td></tr>
<tr class="memdesc:gab73fd60fa5ec55b12441ecbf3224f742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of segment by address.  <a href="#gab73fd60fa5ec55b12441ecbf3224f742">More...</a><br /></td></tr>
<tr class="separator:gab73fd60fa5ec55b12441ecbf3224f742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d41eff5ac1b01d2c2f1455100d0450e"><td class="memItemLeft" align="right" valign="top"><a id="ga0d41eff5ac1b01d2c2f1455100d0450e"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga0d41eff5ac1b01d2c2f1455100d0450e">get_next_seg</a> (ea_t ea)</td></tr>
<tr class="memdesc:ga0d41eff5ac1b01d2c2f1455100d0450e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the next segment. <br /></td></tr>
<tr class="separator:ga0d41eff5ac1b01d2c2f1455100d0450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd68779bb7c22bc90b0659caac7da7b"><td class="memItemLeft" align="right" valign="top"><a id="gabcd68779bb7c22bc90b0659caac7da7b"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gabcd68779bb7c22bc90b0659caac7da7b">get_prev_seg</a> (ea_t ea)</td></tr>
<tr class="memdesc:gabcd68779bb7c22bc90b0659caac7da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the previous segment. <br /></td></tr>
<tr class="separator:gabcd68779bb7c22bc90b0659caac7da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd01f4c4e74fa760a8f2fd99ae2836e3"><td class="memItemLeft" align="right" valign="top"><a id="gadd01f4c4e74fa760a8f2fd99ae2836e3"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gadd01f4c4e74fa760a8f2fd99ae2836e3">get_first_seg</a> (void)</td></tr>
<tr class="memdesc:gadd01f4c4e74fa760a8f2fd99ae2836e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the first segment. <br /></td></tr>
<tr class="separator:gadd01f4c4e74fa760a8f2fd99ae2836e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a1aa4658af45e1e21904bc3169fe1c"><td class="memItemLeft" align="right" valign="top"><a id="ga94a1aa4658af45e1e21904bc3169fe1c"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga94a1aa4658af45e1e21904bc3169fe1c">get_last_seg</a> (void)</td></tr>
<tr class="memdesc:ga94a1aa4658af45e1e21904bc3169fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the last segment. <br /></td></tr>
<tr class="separator:ga94a1aa4658af45e1e21904bc3169fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f20bda4f664e25e179a391ee9690e1f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga6f20bda4f664e25e179a391ee9690e1f">get_segm_by_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga6f20bda4f664e25e179a391ee9690e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by its name.  <a href="#ga6f20bda4f664e25e179a391ee9690e1f">More...</a><br /></td></tr>
<tr class="separator:ga6f20bda4f664e25e179a391ee9690e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadde01303718a6cde673dca12ffac9d7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gaadde01303718a6cde673dca12ffac9d7">set_segm_end</a> (ea_t ea, ea_t newend, int flags)</td></tr>
<tr class="memdesc:gaadde01303718a6cde673dca12ffac9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment end address.  <a href="#gaadde01303718a6cde673dca12ffac9d7">More...</a><br /></td></tr>
<tr class="separator:gaadde01303718a6cde673dca12ffac9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffcd6c25a6d3bfc4bafeb786db81ec79"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gaffcd6c25a6d3bfc4bafeb786db81ec79">set_segm_start</a> (ea_t ea, ea_t newstart, int flags)</td></tr>
<tr class="memdesc:gaffcd6c25a6d3bfc4bafeb786db81ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment start address.  <a href="#gaffcd6c25a6d3bfc4bafeb786db81ec79">More...</a><br /></td></tr>
<tr class="separator:gaffcd6c25a6d3bfc4bafeb786db81ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gaa93c02cc5dccb84dc5d302dc8dcf67dc">move_segm_start</a> (ea_t ea, ea_t newstart, int mode)</td></tr>
<tr class="memdesc:gaa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move segment start.  <a href="#gaa93c02cc5dccb84dc5d302dc8dcf67dc">More...</a><br /></td></tr>
<tr class="separator:gaa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c11fbdf0ac345cb618b8b0ad3ef04c"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gab3c11fbdf0ac345cb618b8b0ad3ef04c">move_segm</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, ea_t to, int flags=0)</td></tr>
<tr class="memdesc:gab3c11fbdf0ac345cb618b8b0ad3ef04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a segment to a new address.  <a href="#gab3c11fbdf0ac345cb618b8b0ad3ef04c">More...</a><br /></td></tr>
<tr class="separator:gab3c11fbdf0ac345cb618b8b0ad3ef04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f20d1b84b6cbccb5a4b173f26e3599"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gaa5f20d1b84b6cbccb5a4b173f26e3599">rebase_program</a> (adiff_t delta, int flags)</td></tr>
<tr class="memdesc:gaa5f20d1b84b6cbccb5a4b173f26e3599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebase the whole program by 'delta' bytes.  <a href="#gaa5f20d1b84b6cbccb5a4b173f26e3599">More...</a><br /></td></tr>
<tr class="separator:gaa5f20d1b84b6cbccb5a4b173f26e3599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#ga4ad15e77b3eb0f53f1b5083aa0c3a70b">change_segment_status</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, bool is_deb_segm)</td></tr>
<tr class="memdesc:ga4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a debugger segment to a regular segment and vice versa.  <a href="#ga4ad15e77b3eb0f53f1b5083aa0c3a70b">More...</a><br /></td></tr>
<tr class="separator:ga4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35ca9fdec8cedd3d0fb74cf66506dfd"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gae35ca9fdec8cedd3d0fb74cf66506dfd">take_memory_snapshot</a> (bool only_loader_segs)</td></tr>
<tr class="memdesc:gae35ca9fdec8cedd3d0fb74cf66506dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a memory snapshot of the running process.  <a href="#gae35ca9fdec8cedd3d0fb74cf66506dfd">More...</a><br /></td></tr>
<tr class="separator:gae35ca9fdec8cedd3d0fb74cf66506dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gac6e9fffcb08d5be5a4d94b5f30a84be2">is_miniidb</a> (void)</td></tr>
<tr class="memdesc:gac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the database a miniidb created by the debugger?.  <a href="#gac6e9fffcb08d5be5a4d94b5f30a84be2">More...</a><br /></td></tr>
<tr class="separator:gac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb1707a8b4bec1a05923aa43c4c06f0"><td class="memItemLeft" align="right" valign="top"><a id="gacdb1707a8b4bec1a05923aa43c4c06f0"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__seg__man.html#gacdb1707a8b4bec1a05923aa43c4c06f0">set_segm_base</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, ea_t newbase)</td></tr>
<tr class="memdesc:gacdb1707a8b4bec1a05923aa43c4c06f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function. <br /></td></tr>
<tr class="separator:gacdb1707a8b4bec1a05923aa43c4c06f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa38d0afa3faaa85ce63da0a69882bc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa38d0afa3faaa85ce63da0a69882bc60">&#9670;&nbsp;</a></span>add_segm_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_segm_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *NONNULL&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new segment. </p>
<p>If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to filled segment structure. segment selector should have proper mapping (see <a class="el" href="group__seg__sel.html#gaee421bd585e301aea9452c84ac735c6a" title="Set mapping of selector to a paragraph.">set_selector()</a>).<ul>
<li>if s.start_ea==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> then s.start_ea &lt;- get_segm_base(&amp;s)</li>
<li>if s.end_ea==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created).</li>
<li>if the s.end_ea &lt; s.start_ea, then fail.</li>
<li>if s.end_ea is too high and the new segment would overlap the next segment, s.end_ea is adjusted properly. </li>
</ul>
</td></tr>
    <tr><td class="paramname">name</td><td>name of new segment. may be NULL. if specified, the segment is immediately renamed </td></tr>
    <tr><td class="paramname">sclass</td><td>class of the segment. may be NULL. if specified, the segment class is immediately changed </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___a_d_d_s_e_g__.html">Add segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59f6ee9677c2605aeac9541e38e54025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f6ee9677c2605aeac9541e38e54025">&#9670;&nbsp;</a></span>add_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_segm </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>para</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new segment, second form. </p>
<p>Segment alignment is set to <a class="el" href="group__sa__.html#ga0aecfd12e64028f0712d6cad0403b66b" title="Relocatable, byte aligned.">saRelByte</a>. Segment combination is "public" or "stack" (if segment class is "STACK"). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to <a class="el" href="pro_8h.html#a893ddf307fae0a3bbca667ee917cddc7" title="&#39;bad selector&#39; value">BADSEL</a>. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">para</td><td>segment base paragraph. if paragraph can't fit in 16bit, then a new selector is allocated and mapped to the paragraph. </td></tr>
    <tr><td class="paramname">start</td><td>start address of the segment. if start==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> then start &lt;- to_ea(para,0). </td></tr>
    <tr><td class="paramname">end</td><td>end address of the segment. end address should be higher than start address. For emulate empty segments, use <a class="el" href="group___s_e_g__.html#ga594f82f31d1ed7189ad21c3af3279269" title="zero-length segment">SEG_NULL</a> segment type. If the end address is lower than start address, then fail. If end==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created). If 'end' is too high and the new segment would overlap the next segment, 'end' is adjusted properly. </td></tr>
    <tr><td class="paramname">name</td><td>name of new segment. may be NULL </td></tr>
    <tr><td class="paramname">sclass</td><td>class of the segment. may be NULL. type of the new segment is modified if class is one of predefined names:<ul>
<li>"CODE" -&gt; <a class="el" href="group___s_e_g__.html#gacfc10101b1288e858b747c0a9c329226" title="code segment">SEG_CODE</a></li>
<li>"DATA" -&gt; <a class="el" href="group___s_e_g__.html#ga9f583dca1a7fef2948458048c70b2f1c" title="data segment">SEG_DATA</a></li>
<li>"CONST" -&gt; <a class="el" href="group___s_e_g__.html#ga9f583dca1a7fef2948458048c70b2f1c" title="data segment">SEG_DATA</a></li>
<li>"STACK" -&gt; <a class="el" href="group___s_e_g__.html#ga0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>"BSS" -&gt; <a class="el" href="group___s_e_g__.html#ga0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>"XTRN" -&gt; <a class="el" href="group___s_e_g__.html#ga5c9bbede59653b945dacc70598306289" title="* segment with &#39;extern&#39; definitions.">SEG_XTRN</a></li>
<li>"COMM" -&gt; <a class="el" href="group___s_e_g__.html#ga39a39aa78e00ea21899571a2b636976e" title="* segment with communal definitions">SEG_COMM</a></li>
<li>"ABS" -&gt; <a class="el" href="group___s_e_g__.html#ga5c130d299e48ff537068e03e8ae23d71" title="* segment with definitions of absolute symbols">SEG_ABSSYM</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabebbd185abaf370753d5ea59d32d9985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabebbd185abaf370753d5ea59d32d9985">&#9670;&nbsp;</a></span>del_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_segm </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, no segment at 'ea'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe3790d2192e868f169f36b97b9afb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe3790d2192e868f169f36b97b9afb38">&#9670;&nbsp;</a></span>getseg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a>* ida_export getseg </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by linear address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address belonging to the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or pointer to segment structure </dd></dl>

</div>
</div>
<a id="ga981ad2476fa596106a40f407583413cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga981ad2476fa596106a40f407583413cb">&#9670;&nbsp;</a></span>getnseg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a>* ida_export getnseg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by its number. </p>
<dl class="section warning"><dt>Warning</dt><dd>Obsoleted because it can slow down the debugger (it has to refresh the whole memory segmentation to calculate the correct answer) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>segment number in the range (0..<a class="el" href="group__seg__man.html#ga9e848ee2505a32634309a914195fe141" title="Get number of segments.">get_segm_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or pointer to segment structure </dd></dl>

</div>
</div>
<a id="gab73fd60fa5ec55b12441ecbf3224f742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73fd60fa5ec55b12441ecbf3224f742">&#9670;&nbsp;</a></span>get_segm_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_segm_num </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of segment by address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address belonging to the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..<a class="el" href="group__seg__man.html#ga9e848ee2505a32634309a914195fe141" title="Get number of segments.">get_segm_qty()</a>-1) </dd></dl>

</div>
</div>
<a id="ga6f20bda4f664e25e179a391ee9690e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f20bda4f664e25e179a391ee9690e1f">&#9670;&nbsp;</a></span>get_segm_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a>* ida_export get_segm_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by its name. </p>
<p>If there are several segments with the same name, returns the first of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>segment name. may be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or pointer to segment structure </dd></dl>

</div>
</div>
<a id="gaadde01303718a6cde673dca12ffac9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadde01303718a6cde673dca12ffac9d7">&#9670;&nbsp;</a></span>set_segm_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segm_end </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment end address. </p>
<p>The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newend</td><td>new end address of the segment </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaffcd6c25a6d3bfc4bafeb786db81ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffcd6c25a6d3bfc4bafeb786db81ec79">&#9670;&nbsp;</a></span>set_segm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segm_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment start address. </p>
<p>The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newstart</td><td>new start address of the segment note that segment start address should be higher than segment base linear address. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa93c02cc5dccb84dc5d302dc8dcf67dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa93c02cc5dccb84dc5d302dc8dcf67dc">&#9670;&nbsp;</a></span>move_segm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export move_segm_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move segment start. </p>
<p>The main difference between this function and <a class="el" href="group__seg__man.html#gaffcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a> is that this function may expand the previous segment while <a class="el" href="group__seg__man.html#gaffcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a> never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. </p><dl class="section note"><dt>Note</dt><dd>this function never disables addresses. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newstart</td><td>new start address of the segment note that segment start address should be higher than segment base linear address. </td></tr>
    <tr><td class="paramname">mode</td><td>policy for destroying defined items<ul>
<li>0: if it is necessary to destroy defined items, display a dialog box and ask confirmation</li>
<li>1: if it is necessary to destroy defined items, just destroy them without asking the user</li>
<li>-1: if it is necessary to destroy defined items, don't destroy them (i.e. function will fail)</li>
<li>-2: don't destroy defined items (function will succeed) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3c11fbdf0ac345cb618b8b0ad3ef04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c11fbdf0ac345cb618b8b0ad3ef04c">&#9670;&nbsp;</a></span>move_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export move_segm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a segment to a new address. </p>
<p>This function moves all information to the new address. It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, <a class="el" href="structloader__t.html#a7a329922101a4e28a2b7018e565a3b5d" title="Take care of a moved segment (fix up relocations, for example).">loader_t::move_segm</a> is called. Also IDB notification event <a class="el" href="namespaceidb__event.html#a0feb6e648b4e6e3f0ed954abea672784a9462c0eec099edd1bb2f0d7e65acf2e5" title="Segment has been moved.">idb_event::segm_moved</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>segment to move </td></tr>
    <tr><td class="paramname">to</td><td>new segment start address </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___m_s_f__.html">Move segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_o_v_e___s_e_g_m__.html">Move segment result codes</a> </dd></dl>

</div>
</div>
<a id="gaa5f20d1b84b6cbccb5a4b173f26e3599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5f20d1b84b6cbccb5a4b173f26e3599">&#9670;&nbsp;</a></span>rebase_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export rebase_program </td>
          <td>(</td>
          <td class="paramtype">adiff_t&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebase the whole program by 'delta' bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>number of bytes to move the program </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___m_s_f__.html">Move segment flags</a> it is recommended to use <a class="el" href="group___m_s_f__.html#ga89693134e1c29045c8c9a1b77f106813" title="call loader only once with the special calling method.">MSF_FIXONCE</a> so that the loader takes care of global variables it stored in the database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_o_v_e___s_e_g_m__.html">Move segment result codes</a> </dd></dl>

</div>
</div>
<a id="ga4ad15e77b3eb0f53f1b5083aa0c3a70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ad15e77b3eb0f53f1b5083aa0c3a70b">&#9670;&nbsp;</a></span>change_segment_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export change_segment_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deb_segm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a debugger segment to a regular segment and vice versa. </p>
<p>When converting debug-&gt;regular, the memory contents will be copied to the database. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>segment to modify </td></tr>
    <tr><td class="paramname">is_deb_segm</td><td>new status of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___c_s_s__.html">Change segment status result codes</a> </dd></dl>

</div>
</div>
<a id="gae35ca9fdec8cedd3d0fb74cf66506dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae35ca9fdec8cedd3d0fb74cf66506dfd">&#9670;&nbsp;</a></span>take_memory_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export take_memory_snapshot </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_loader_segs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a memory snapshot of the running process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">only_loader_segs</td><td>only is_loader_segm() segments will be affected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="gac6e9fffcb08d5be5a4d94b5f30a84be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e9fffcb08d5be5a4d94b5f30a84be2">&#9670;&nbsp;</a></span>is_miniidb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_miniidb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the database a miniidb created by the debugger?. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the database contains no segments or only debugger segments </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
